<!DOCTYPE html>
<html lang="es">
  <head>
    <meta charset="UTF-8" />
    <title>Hero 3D Network</title>
    <style>
      html, body {
        margin: 0;
        padding: 0;
        background-color: #001f2f;
        overflow: hidden;
      }
      canvas {
        display: block;
      }
    </style>
  </head>
  <body>
    <!-- Cargamos Three.js y OrbitControls desde CDN confiables -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.150.1/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.150.1/examples/js/controls/OrbitControls.js"></script>

    <script>
      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(
        75, window.innerWidth / window.innerHeight, 0.1, 1000
      );

      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      // Esfera en forma de red
      const sphereGeometry = new THREE.SphereGeometry(3, 32, 32);
      const wireMaterial = new THREE.LineBasicMaterial({ color: 0x00ffff });
      const wireframe = new THREE.WireframeGeometry(sphereGeometry);
      const globe = new THREE.LineSegments(wireframe, wireMaterial);
      scene.add(globe);

      // Conexiones aleatorias
      const connectionMaterial = new THREE.LineBasicMaterial({ color: 0xffffff });
      function createConnections(count) {
        for (let i = 0; i < count; i++) {
          const lat1 = Math.random() * Math.PI;
          const lon1 = Math.random() * 2 * Math.PI;
          const lat2 = Math.random() * Math.PI;
          const lon2 = Math.random() * 2 * Math.PI;
          const r = 3;

          const x1 = r * Math.sin(lat1) * Math.cos(lon1);
          const y1 = r * Math.sin(lat1) * Math.sin(lon1);
          const z1 = r * Math.cos(lat1);

          const x2 = r * Math.sin(lat2) * Math.cos(lon2);
          const y2 = r * Math.sin(lat2) * Math.sin(lon2);
          const z2 = r * Math.cos(lat2);

          const points = [
            new THREE.Vector3(x1, y1, z1),
            new THREE.Vector3(x2, y2, z2),
          ];

          const geo = new THREE.BufferGeometry().setFromPoints(points);
          const line = new THREE.Line(geo, connectionMaterial);
          scene.add(line);
        }
      }

      createConnections(100);

      const controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.autoRotate = true;
      controls.autoRotateSpeed = 0.5;

      camera.position.z = 8;

      window.addEventListener("resize", () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });

      function animate() {
        requestAnimationFrame(animate);
        controls.update();
        renderer.render(scene, camera);
      }

      animate();
    </script>
  </body>
</html>
